---
layout: post
title: java 垃圾回收
date: 2018-09-06
author: "Xsp"
catalog: true
tags:
    - Java
---



内容来自《深入理解java虚拟机》 第3章 垃圾收集器与内存分配策略



### 永久代？





### 怎么判断对象是否存活？

#### 引用计数算法

会有循环引用的问题

#### 可达性分析算法（✔️）

从 GC Roots 节点开始向下搜索，搜不到的则判定为可回收的对象。

可以作为GC Roots 的对象：

- 虚拟机栈中引用的对象
- 方法区中类静态对象属性引用的对象
- 方法区常量引用的对象
- 本地方法栈JNI对象引用的对象

这里不是很懂，为啥是这些对象？咋没有堆呢？

#### 引用分类

- 强引用：一般代码中写的，`OBject obj = new Object()`
- 软引用：有用但不必要，在即将发生内存溢出时才会删掉。可以用 `SoftReference` 类来实现。
- 弱引用：非必须对象，被弱引用关联的对象只能生存到下次垃圾回收之前。
- 虚引用：没啥用，在这个对象被回收时收到一个系统通知。可以用 PhantomReference。

#### 可达性分析 - > 两次标记

不是很懂

#### 回收方法区和永久代

。。



###垃圾收集算法

#### 标记清除

不足：

- 效率不高
- 空间问题，清除之后产生大量碎片，如果再分配大的对象，无法找到足够的内存又会触发垃圾回收。

#### 复制算法

将内存容量划分为大小相等的两块，每次用一块，一块用完了，再将存活的对象复制到另一块上，然后把已经使用过的内存空间一次清理。

